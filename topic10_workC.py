"""
C. –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ç–µ—Å—Ç2 —Å–µ–∫—É–Ω–¥—ã
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ç–µ—Å—Ç256 –º–µ–≥–∞–±–∞–π—Ç
–≤–≤–æ–¥—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥
–≤—ã–≤–æ–¥—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥
–î–∞–Ω –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –Ω–µ–≤–∑–≤–µ—à–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –µ–≥–æ —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫—É—é —Å–æ—Ä—Ç–∏—Ä–≤–æ–∫—É.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –¥–∞–Ω—ã –¥–≤–∞ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–ª–∞ ùëõ –∏ ùëö (1‚â§ùëõ‚â§100000, 0‚â§ùëö‚â§100000) ‚Äî —á–∏—Å–ª–æ –≤–µ—Ä—à–∏–Ω –∏ —Ä—ë–±–µ—Ä –≤ –≥—Ä–∞—Ñ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ. –î–∞–ª–µ–µ –≤ ùëö —Å—Ç—Ä–æ–∫–∞—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω—ã —Ä—ë–±—Ä–∞ –≥—Ä–∞—Ñ–∞. –ö–∞–∂–¥–æ–µ —Ä–µ–±—Ä–æ –∑–∞–¥–∞—ë—Ç—Å—è –ø–∞—Ä–æ–π —á–∏—Å–µ–ª ‚Äî –Ω–æ–º–µ—Ä–∞–º–∏ –Ω–∞—á–∞–ª—å–Ω–æ–π –∏ –∫–æ–Ω–µ—á–Ω–æ–π –≤–µ—Ä—à–∏–Ω —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í—ã–≤–µ–¥–∏—Ç–µ –ª—é–±—É—é —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫—É—é —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –≥—Ä–∞—Ñ–∞ –≤ –≤–∏–¥–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –Ω–æ–º–µ—Ä–æ–≤ –≤–µ—Ä—à–∏–Ω. –ï—Å–ª–∏ –≥—Ä–∞—Ñ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å, –≤—ã–≤–µ–¥–∏—Ç–µ ‚àí1.

–ü—Ä–∏–º–µ—Ä
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å
6 6
1 2
3 2
4 2
2 5
6 5
4 6
–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å
4 6 3 1 2 5 

"""
from sys import setrecursionlimit
import threading
from collections import defaultdict, deque
 
 
def topological_sort(graph: defaultdict, n_nodes: int):
    """
    Topological sorting algorithm
    :param graph: graph as dict with lists of children nodes
    :param n_nodes: number of nodes in graph
    :return: nodes ordered in topological order
    """
    seen = set()
    result = deque()
    has_cycles = False
 
    WHITE = 0
    GRAY = 1
    BLACK = 2
    colors = [WHITE for _ in range(n_nodes)]
 
    def dfs(node_src: int, passed):
        nonlocal has_cycles
        seen.add(node_src)
        colors[node_src - 1] = GRAY
        for node_trg in graph[node_src]:
            if colors[node_trg - 1] == WHITE:
                dfs(node_trg, passed)
            if colors[node_trg - 1] == GRAY:
                has_cycles = True
                break
        colors[node_src - 1] = BLACK
        if not has_cycles:
            result.appendleft(node_src)
 
    for node in range(1, n_nodes + 1):
        if node not in seen:
            passed_in_traverse = set()
            dfs(node, passed_in_traverse)
    if has_cycles:
        return [-1]
    else:
        return result
 
 
def main():
    graph = defaultdict(list)
    n_nodes, n_edges = [int(x) for x in input().split()]
    for _ in range(n_edges):
        node_src, node_trg = [int(x) for x in input().split()]
        graph[node_src].append(node_trg)
    print(
        " ".join(
            map(str, topological_sort(graph=graph, n_nodes=n_nodes))
        )
    )
 
 
setrecursionlimit(10 ** 9)
threading.stack_size(2 ** 26)
thread = threading.Thread(target=main)
thread.start()