/**
A. –ú–∏–Ω–∏–º—É–º –Ω–∞ —Å—Ç–µ–∫–µ
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ç–µ—Å—Ç2 —Å–µ–∫—É–Ω–¥—ã
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –ø–∞–º—è—Ç–∏ –Ω–∞ —Ç–µ—Å—Ç256 –º–µ–≥–∞–±–∞–π—Ç
–≤–≤–æ–¥—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤–≤–æ–¥
–≤—ã–≤–æ–¥—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥
–í–∞–º —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö, –≤—ã–ø–æ–ª–Ω—è—é—â—É—é —Å–ª–µ–¥—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:

–î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç ùë• –≤ –∫–æ–Ω–µ—Ü —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.
–£–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.
–í—ã–¥–∞—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ.
–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∑–∞–¥–∞–Ω–æ –æ–¥–Ω–æ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ùëõ ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π (1‚â§ùëõ‚â§106). –í —Å–ª–µ–¥—É—é—â–∏—Ö ùëõ —Å—Ç—Ä–æ–∫–∞—Ö –∑–∞–¥–∞–Ω—ã —Å–∞–º–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏. –í ùëñ‚Äì–æ–π —Å—Ç—Ä–æ–∫–µ —á–∏—Å–ª–æ ùë°ùëñ ‚Äî —Ç–∏–ø –æ–ø–µ—Ä–∞—Ü–∏–∏ (1, –µ—Å–ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è. 2, –µ—Å–ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è. 3, –µ—Å–ª–∏ –æ–ø–µ—Ä–∞—Ü–∏—è –º–∏–Ω–∏–º—É–º–∞). –ï—Å–ª–∏ –∑–∞–¥–∞–Ω–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è, —Ç–æ —á–µ—Ä–µ–∑ –ø—Ä–æ–±–µ–ª –∑–∞–ø–∏—Å–∞–Ω–æ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ùë• ‚Äî —ç–ª–µ–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–ª–µ–¥—É–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É (‚àí109‚â§ùë•‚â§109). –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è, —á—Ç–æ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π —É–¥–∞–ª–µ–Ω–∏—è –∏–ª–∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –º–∏–Ω–∏–º—É–º–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–µ –ø—É—Å—Ç–∞.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–î–ª—è –∫–∞–∂–¥–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –º–∏–Ω–∏–º—É–º–∞ –≤—ã–≤–µ–¥–∏—Ç–µ –æ–¥–Ω–æ —á–∏—Å–ª–æ ‚Äî –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ. –û—Ç–≤–µ—Ç—ã —Ä–∞–∑–¥–µ–ª—è–π—Ç–µ –ø–µ—Ä–µ–≤–æ–¥–æ–º —Å—Ç—Ä–æ–∫–∏.

–ü—Ä–∏–º–µ—Ä
–≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å
8
1 2
1 3
1 -3
3
2
3
2
3
–≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å
-3
2
2

**/
#include <cassert>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
 
typedef long long value_t;
 
template <typename data_t>
struct Node : std::enable_shared_from_this<Node<data_t> > {
 public:
  data_t data;
  data_t prev_min;
  bool is_first;
  std::shared_ptr<Node<data_t> > next;
  std::weak_ptr<Node<data_t> > prev;
  std::string to_string();
  data_t get_min();
};
 
template <typename data_t>
std::string Node<data_t>::to_string() {
  std::string result = std::to_string(this->data);
  return result;
}
 
template <typename data_t>
data_t Node<data_t>::get_min() {
  return (is_first or data < prev_min) ? data : prev_min;
}
 
void test_node() {
  Node<value_t> *n1 = new Node<value_t>(), *n2 = new Node<value_t>(),
                *n3 = new Node<value_t>();
  std::shared_ptr<Node<value_t> > ptr_n1(n1), ptr_n2(n2), ptr_n3(n3);
 
  ptr_n1->data = 1;
  ptr_n2->data = 2;
  ptr_n3->data = 3;
 
  ptr_n1->next = ptr_n2;
  ptr_n2->prev = ptr_n1;
 
  ptr_n2->next = ptr_n3;
  ptr_n3->prev = ptr_n2;
 
  assert(ptr_n1->data == 1);
  assert(ptr_n1->next == ptr_n2);
  assert(ptr_n1->prev.expired());
  assert(n1->prev.lock() == nullptr);
  assert(ptr_n1->next->data == 2);
  assert(ptr_n1->to_string() == "1");
 
  assert(ptr_n2->data == 2);
  assert(ptr_n2->prev.lock() == ptr_n1);
  assert(ptr_n2->next == ptr_n3);
  assert(ptr_n2->prev.lock()->data == 1);
  assert(ptr_n2->next->data == 3);
  assert(ptr_n2->to_string() == "2");
 
  assert(ptr_n3->data == 3);
  assert(ptr_n3->prev.lock() == ptr_n2);
  assert(ptr_n3->next == nullptr);
  assert(ptr_n3->prev.lock()->data == 2);
  assert(ptr_n3->to_string() == "3");
  std::cout << "test_node: ok (1/2)\n";
 
  ptr_n2->data = 20;
  assert(ptr_n1->next->data == 20);
  assert(ptr_n3->prev.lock()->data == 20);
  std::cout << "test_node: ok (2/2)\n";
}
 
template <typename data_t>
class MinStack {
 private:
  std::shared_ptr<Node<data_t> > head, tail;
  long long length = 0;
  void init(data_t data);
 
 public:
  std::string to_string();
  void push_back(data_t data);
  data_t back();
  void pop_back();
  data_t get_min();
};
 
template <typename data_t>
void MinStack<data_t>::init(data_t data) {
  Node<data_t> *node = new Node<data_t>();
  node->data = data;
  node->is_first = true;
  tail = std::shared_ptr<Node<data_t> >(node);
  head = tail;
}
 
template <typename data_t>
void MinStack<data_t>::push_back(data_t data) {
  if (tail == nullptr)
    init(data);
  else {
    Node<data_t> *node = new Node<data_t>();
    node->data = data;
    std::shared_ptr<Node<data_t> > ptr_node(node), tmp = tail;
    tail = ptr_node;
    ptr_node->prev = tmp;
    tmp->next = ptr_node;
 
    tail->prev_min = tail->prev.lock()->get_min();
  }
  length++;
}
 
template <typename data_t>
data_t MinStack<data_t>::back() {
  return tail->data;
}
 
template <typename data_t>
void MinStack<data_t>::pop_back() {
  if (length == 1) {
    head = nullptr;
    tail = nullptr;
    length--;
  } else if (length > 1) {
    tail = tail->prev.lock();
    tail->next = nullptr;
    length--;
  }
}
 
template <typename data_t>
std::string MinStack<data_t>::to_string() {
  std::string result = "[";
  std::shared_ptr<Node<data_t> > curr = head;
  while (curr != nullptr) {
    result += curr->to_string();
    if (curr->next != nullptr) result += " ";
    curr = curr->next;
  }
  result += "]";
  return result;
}
 
template <typename data_t>
data_t MinStack<data_t>::get_min() {
  return tail->get_min();
}
 
void test_minstack() {
  MinStack<value_t> stack;
  stack.push_back(10);
  stack.push_back(20);
  stack.push_back(3);
  assert(stack.to_string() == "[10 20 3]");
  assert(stack.get_min() == 3);
  assert(stack.back() == 3);
  std::cout << "test_list: ok (1/2)\n";
  stack.pop_back();
  assert(stack.to_string() == "[10 20]");
  assert(stack.get_min() == 10);
  assert(stack.back() == 20);
  std::cout << "test_list: ok (2/2)\n";
}
 
void cli_dialog(bool verbose = false) {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(NULL);
 
  MinStack<value_t> stack;
  std::istringstream sstream;
  long long n_qry = 0;
  std::string command, result = "";
  std::cin >> n_qry;
  std::cin.ignore();
  if (verbose) std::cout << "nqry=" << n_qry << "\n";
  for (long long i = 0; i < n_qry; i++) {
    getline(std::cin, command);
    if (verbose) std::cout << "cmd=" << command << "\n";
    if (command[0] == '1') {
      sstream = std::istringstream(command);
      short cmd;
      value_t value;
      sstream >> cmd >> value;
      stack.push_back(value);
    } else if (command[0] == '2') {
      stack.pop_back();
    } else if (command[0] == '3') {
      result += (std::to_string(stack.get_min()) + "\n");
    }
  }
  std::cout << result;
}
 
int main() {
  // test_node();
  // test_minstack();
  cli_dialog();
  return 0;
}