/*
A. Ð¡Ð±Ð°Ð»Ð°Ð½ÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ Ð´Ð²Ð¾Ð¸Ñ‡Ð½Ð¾Ðµ Ð´ÐµÑ€ÐµÐ²Ð¾ Ð¿Ð¾Ð¸ÑÐºÐ°
Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ Ð½Ð° Ñ‚ÐµÑÑ‚2 ÑÐµÐºÑƒÐ½Ð´Ñ‹
Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð¿Ð°Ð¼ÑÑ‚Ð¸ Ð½Ð° Ñ‚ÐµÑÑ‚512 Ð¼ÐµÐ³Ð°Ð±Ð°Ð¹Ñ‚
Ð²Ð²Ð¾Ð´ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ Ð²Ð²Ð¾Ð´
Ð²Ñ‹Ð²Ð¾Ð´ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ñ‹Ð¹ Ð²Ñ‹Ð²Ð¾Ð´
Ð ÐµÐ°Ð»Ð¸Ð·ÑƒÐ¹Ñ‚Ðµ ÑÐ±Ð°Ð»Ð°Ð½ÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ Ð´Ð²Ð¾Ð¸Ñ‡Ð½Ð¾Ðµ Ð´ÐµÑ€ÐµÐ²Ð¾ Ð¿Ð¾Ð¸ÑÐºÐ°.

Ð’Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ
Ð’Ñ…Ð¾Ð´Ð½Ð¾Ð¹ Ñ„Ð°Ð¹Ð» ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¹ Ñ Ð´ÐµÑ€ÐµÐ²Ð¾Ð¼, Ð¸Ñ… ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð½Ðµ Ð¿Ñ€ÐµÐ²Ñ‹ÑˆÐ°ÐµÑ‚ 105. Ð’ ÐºÐ°Ð¶Ð´Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐµ Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ÑÑ Ð¾Ð´Ð½Ð° Ð¸Ð· ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ñ… Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¹:

insert ð‘¥ â€” Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð² Ð´ÐµÑ€ÐµÐ²Ð¾ ÐºÐ»ÑŽÑ‡ ð‘¥. Ð•ÑÐ»Ð¸ ÐºÐ»ÑŽÑ‡ ð‘¥ ÐµÑÑ‚ÑŒ Ð² Ð´ÐµÑ€ÐµÐ²Ðµ, Ñ‚Ð¾ Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð½Ðµ Ð½Ð°Ð´Ð¾;
delete ð‘¥ â€” ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð¸Ð· Ð´ÐµÑ€ÐµÐ²Ð° ÐºÐ»ÑŽÑ‡ ð‘¥. Ð•ÑÐ»Ð¸ ÐºÐ»ÑŽÑ‡Ð° ð‘¥ Ð² Ð´ÐµÑ€ÐµÐ²Ðµ Ð½ÐµÑ‚, Ñ‚Ð¾ Ð½Ð¸Ñ‡ÐµÐ³Ð¾ Ð´ÐµÐ»Ð°Ñ‚ÑŒ Ð½Ðµ Ð½Ð°Ð´Ð¾;
exists ð‘¥ â€” ÐµÑÐ»Ð¸ ÐºÐ»ÑŽÑ‡ ð‘¥ ÐµÑÑ‚ÑŒ Ð² Ð´ÐµÑ€ÐµÐ²Ðµ Ð²Ñ‹Ð²ÐµÐ´Ð¸Ñ‚Ðµ Â«trueÂ», ÐµÑÐ»Ð¸ Ð½ÐµÑ‚ Â«falseÂ»;
next ð‘¥ â€” Ð²Ñ‹Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ Ð² Ð´ÐµÑ€ÐµÐ²Ðµ, ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ð±Ð¾Ð»ÑŒÑˆÐ¸Ð¹ ð‘¥, Ð¸Ð»Ð¸ Â«noneÂ» ÐµÑÐ»Ð¸ Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ð½ÐµÑ‚;
prev ð‘¥ â€” Ð²Ñ‹Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ Ð² Ð´ÐµÑ€ÐµÐ²Ðµ, ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ð¼ÐµÐ½ÑŒÑˆÐ¸Ð¹ ð‘¥, Ð¸Ð»Ð¸ Â«noneÂ» ÐµÑÐ»Ð¸ Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ð½ÐµÑ‚.
Ð’ Ð´ÐµÑ€ÐµÐ²Ð¾ Ð¿Ð¾Ð¼ÐµÑ‰Ð°ÑŽÑ‚ÑÑ Ð¸ Ð¸Ð·Ð²Ð»ÐµÐºÐ°ÑŽÑ‚ÑÑ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ†ÐµÐ»Ñ‹Ðµ Ñ‡Ð¸ÑÐ»Ð°, Ð½Ðµ Ð¿Ñ€ÐµÐ²Ñ‹ÑˆÐ°ÑŽÑ‰Ð¸Ðµ Ð¿Ð¾ Ð¼Ð¾Ð´ÑƒÐ»ÑŽ 109.
Ð’Ñ‹Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ
Ð’Ñ‹Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð²ÑÐµÑ… Ð¾Ð¿ÐµÑ€Ð°Ñ†Ð¸Ð¹ exists, next, prev. Ð¡Ð»ÐµÐ´ÑƒÐ¹Ñ‚Ðµ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ñƒ Ð²Ñ‹Ñ…Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ñ„Ð°Ð¹Ð»Ð° Ð¸Ð· Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ð°.

ÐŸÑ€Ð¸Ð¼ÐµÑ€
Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹ÐµÐ¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
Ð²Ñ‹Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹ÐµÐ¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ
true
false
5
3
none
3
*/

package main

import (
	"bufio"
	"container/list"
	"fmt"
	"os"
	"strconv"
	"strings"
)

type Node struct {
	x     int
	y     int
	left  *Node
	right *Node
	// parent *Node
}

type Pair struct {
	level int
	node  *Node
}

// type is_good func(*Node) bool

func to_string(node *Node) string {
	var result string = ""
	buff := list.New()
	buff.PushBack(Pair{level: 0, node: node})
	for buff.Len() > 0 {
		var curr Pair = buff.Back().Value.(Pair)
		result += strings.Repeat(" ", curr.level) + "{x:" + strconv.Itoa(curr.node.x) + " y:" + strconv.Itoa(curr.node.y) + "}\n"
		buff.Remove(buff.Back())
		if node.right != nil {
			buff.PushBack(Pair{level: curr.level + 1, node: node.right})
		}
		if node.left != nil {
			buff.PushBack(Pair{level: curr.level + 1, node: node.left})
		}
	}
	return result
}

func merge(left *Node, right *Node) *Node {
	if right == nil {
		return left
	}
	if left == nil {
		return right
	}
	if left.y > right.y {
		left.right = merge(left.right, right)
		return left
	} else {
		right.left = merge(left, right.left)
		return right
	}
}

func split(node *Node, x int) (*Node, *Node) {
	if node == nil {
		return nil, nil
	} else if node.x > x {
		node_left, node_right := split(node.left, x)
		node.left = node_right
		return node_left, node
	} else {
		node_left, node_right := split(node.right, x)
		node.right = node_left
		return node, node_right
	}
}

// func insert(node *Node, x int, y int) *Node {
// 	node_new := Node{x, y, nil, nil}
// 	if node == nil {
// 		return &node_new
// 	} else {
// 		left, right := split(node, x)
// 		left = merge(left, &node_new)
// 		return merge(left, right)
// 	}
// }

func insert(node *Node, x int, y int) *Node {
	node_new := Node{x, y, nil, nil}
	if node == nil {
		return &node_new
	} else {
		var parent *Node = nil
		var curr *Node = node
		for curr != nil {
			if curr.y < y {
				break
			}
			parent = curr
			if x <= curr.x {
				curr = curr.left
			} else {
				curr = curr.right
			}
		}
		left, right := split(curr, x)
		node_new.left = left
		node_new.right = right
		if parent == nil {
			return &node_new
		} else {
			if x <= parent.x {
				parent.left = &node_new
			} else {
				parent.right = &node_new
			}
		}

		// curr = &node_new
		// if curr == nil {
		// 	if x <= parent.x {
		// 		parent.left = &node_new
		// 	} else {
		// 		parent.right = &node_new
		// 	}
		// 	// curr = &node_new
		// } else {
		// 	left, right := split(curr, x)
		// 	node_new.left = left
		// 	node_new.right = right
		// 	curr = &node_new

		// 	// curr.x = x
		// 	// curr.y = y
		// 	// curr.left = left
		// 	// curr.right = right
		// }
	}
	return node
}

func remove(node *Node, x int) *Node {
	left, right := split(node, x)
	left_2, _ := split(left, x-1)
	return merge(left_2, right)
}

func exists(node *Node, x int) bool {
	var result bool = false
	for node != nil {
		if node.x == x {
			result = true
			break
		}
		if x < node.x {
			node = node.left
		} else if x > node.x {
			node = node.right
		}
	}
	return result
}

func prev(node *Node, x int) *Node {
	var is_initialised bool = false
	var x_max int
	var node_best *Node = nil
	for node != nil {
		if node.x < x {
			if !is_initialised || node.x > x_max {
				x_max = node.x
				node_best = node
				is_initialised = true
			}
		}
		if x < node.x {
			node = node.left
		} else if x > node.x {
			node = node.right
		}
	}
	return node_best
}

func next(node *Node, x int) *Node {
	var is_initialised bool = false
	var x_min int
	var node_best *Node = nil
	for node != nil {
		if node.x > x {
			if !is_initialised || node.x < x_min {
				x_min = node.x
				node_best = node
				is_initialised = true
			}
		}
		if x < node.x {
			node = node.left
		} else if x > node.x {
			node = node.right
		}
	}
	return node_best
}

func cli_dialog() {
	const MAX_Y = 1000000
	var root *Node = nil
	reader := bufio.NewReader(os.Stdin)
	var is_exit bool = false
	var next_y int = 0
	for !is_exit {
		command, err := reader.ReadString('\n')
		if err == nil {
			if strings.HasPrefix(command, "insert") {
				arg, _ := strconv.Atoi(strings.Fields(command)[1])
				root = insert(root, arg, next_y)
				next_y++
			} else if strings.HasPrefix(command, "delete") {
				arg, _ := strconv.Atoi(strings.Fields(command)[1])
				root = remove(root, arg)
			} else if strings.HasPrefix(command, "exists") {
				arg, _ := strconv.Atoi(strings.Fields(command)[1])
				fmt.Println(strconv.FormatBool(exists(root, arg)))
			} else if strings.HasPrefix(command, "next") {
				arg, _ := strconv.Atoi(strings.Fields(command)[1])
				res := next(root, arg)
				if res != nil {
					fmt.Println(res.x)
				} else {
					fmt.Println("none")
				}
			} else if strings.HasPrefix(command, "prev") {
				arg, _ := strconv.Atoi(strings.Fields(command)[1])
				res := prev(root, arg)
				if res != nil {
					fmt.Println(res.x)
				} else {
					fmt.Println("none")
				}
			}
		} else {
			is_exit = true
		}
	}

}

func test_case() {
	const MAX_Y = 1000000
	var root *Node = nil
	var next_y int = 0
	root = insert(root, 2, next_y)
	next_y++
	root = insert(root, 5, next_y)
	next_y++
	root = insert(root, 3, next_y)
	next_y++
	fmt.Println(strconv.FormatBool(exists(root, 2)))
	fmt.Println(strconv.FormatBool(exists(root, 4)))
	fmt.Println(next(root, 4))
	fmt.Println(prev(root, 4))
	root = remove(root, 5)
	fmt.Println(next(root, 4))
	fmt.Println(prev(root, 4))
}

func main() {
	// test_case()
	cli_dialog()
}
