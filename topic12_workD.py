"""
D. ĞÑÑ‚Ğ¾Ğ²Ğ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾ 2
Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸ Ğ½Ğ° Ñ‚ĞµÑÑ‚2 ÑĞµĞºÑƒĞ½Ğ´Ñ‹
Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ½Ğ° Ñ‚ĞµÑÑ‚256 Ğ¼ĞµĞ³Ğ°Ğ±Ğ°Ğ¹Ñ‚
Ğ²Ğ²Ğ¾Ğ´ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ Ğ²Ğ²Ğ¾Ğ´
Ğ²Ñ‹Ğ²Ğ¾Ğ´ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ²Ğ¾Ğ´
Ğ¢Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ² ÑĞ²ÑĞ·Ğ½Ğ¾Ğ¼ Ğ³Ñ€Ğ°Ñ„Ğµ Ğ¾ÑÑ‚Ğ¾Ğ²Ğ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ²ĞµÑĞ°.

Ğ’Ñ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
ĞŸĞµÑ€Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ° Ğ²Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ° ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ´Ğ²Ğ° Ğ½Ğ°Ñ‚ÑƒÑ€Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ‡Ğ¸ÑĞ»Ğ° ğ‘› Ğ¸ ğ‘š â€” ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ²ĞµÑ€ÑˆĞ¸Ğ½ Ğ¸ Ñ€ĞµĞ±ĞµÑ€ Ğ³Ñ€Ğ°Ñ„Ğ° ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾. Ğ¡Ğ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ğµ ğ‘š ÑÑ‚Ñ€Ğ¾Ğº ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ€ĞµĞ±ĞµÑ€ Ğ¿Ğ¾ Ğ¾Ğ´Ğ½Ğ¾Ğ¼Ñƒ Ğ½Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞµ. Ğ ĞµĞ±Ñ€Ğ¾ Ğ½Ğ¾Ğ¼ĞµÑ€ ğ‘– Ğ¾Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ñ‚Ñ€ĞµĞ¼Ñ Ğ½Ğ°Ñ‚ÑƒÑ€Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¼Ğ¸ Ñ‡Ğ¸ÑĞ»Ğ°Ğ¼Ğ¸ ğ‘ğ‘–, ğ‘’ğ‘– Ğ¸ ğ‘¤ğ‘– â€” Ğ½Ğ¾Ğ¼ĞµÑ€Ğ° ĞºĞ¾Ğ½Ñ†Ğ¾Ğ² Ñ€ĞµĞ±Ñ€Ğ° Ğ¸ ĞµĞ³Ğ¾ Ğ²ĞµÑ ÑĞ¾Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ (1â‰¤ğ‘ğ‘–,ğ‘’ğ‘–â‰¤ğ‘›, 0â‰¤ğ‘¤ğ‘–â‰¤100000). ğ‘›â‰¤200000,ğ‘šâ‰¤200000.
Ğ“Ñ€Ğ°Ñ„ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ ÑĞ²ÑĞ·Ğ½Ñ‹Ğ¼.

Ğ’Ñ‹Ñ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
ĞŸĞµÑ€Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ° Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ° Ğ´Ğ¾Ğ»Ğ¶Ğ½Ğ° ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ¾Ğ´Ğ½Ğ¾ Ğ½Ğ°Ñ‚ÑƒÑ€Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ â€” Ğ²ĞµÑ Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ¾ÑÑ‚Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ´ĞµÑ€ĞµĞ²Ğ°.

ĞŸÑ€Ğ¸Ğ¼ĞµÑ€
Ğ²Ñ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹ĞµĞ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
4 4
1 2 1
2 3 2
3 4 5
4 1 4
Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹ĞµĞ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
7

"""

from sys import setrecursionlimit, stdin
import threading
 
 
def init(n: int):
    parent = []
    rank = []
    for i in range(n):
        parent.append(i)
        rank.append(0)
    return parent, rank
 
 
def get(
        idx: int, parent: list,
):
    if parent[idx] != idx:
        parent[idx] = get(parent[idx], parent)
    p_idx = parent[idx]
    return p_idx
 
 
def union(
        left: int, right: int,
        parent: list, rank: list,
):
    left = get(
        idx=left,
        parent=parent,
    )
    right = get(
        idx=right,
        parent=parent,
    )
    if left == right:
        return
    if rank[left] > rank[right]:
        left, right = right, left
    if rank[left] == rank[right]:
        rank[right] += 1
    parent[left] = right
 
 
def kruskal(edges: list, n_nodes: int):
    result = 0
    edges = sorted(edges, key=lambda x: x[0])
    group, rank = init(n_nodes)
    for edge in edges:
        if get(idx=edge[1], parent=group) != get(idx=edge[2], parent=group):
            result += edge[0]
            union(left=edge[1], right=edge[2], parent=group, rank=rank)
    return result
 
 
def main():
    edges = []
    n_nodes, n_edges = [int(x) for x in input().split()]
    for _ in range(n_edges):
        beg, end, weight = [int(x) for x in input().split()]
        edges.append((weight, beg - 1, end - 1))
    print(kruskal(edges, n_nodes))
 
 
setrecursionlimit(10 ** 9)
threading.stack_size(2 ** 26)
thread = threading.Thread(target=main)
thread.start()